from tkinter import *
import random
import time
#K: Inspiration zu grossen Teilen aus der Playlist:
# https://www.youtube.com/watch?v=lc8NNJgeVjI&index=12&list=PLsk-HSGFjnaGe7sS_4VpZoEtZF2VoWtoR

#K: globale Variabeln deklarieren
#K: width, height und size hier initialisieren, damit sie später von überall aufgerufen werden können.
WIDTH = 1200
HEIGHT = 800
size = 20

#K: öffnet neues Fenster mit der Grösse width x height Pixles
tk = Tk()
canvas = Canvas(tk, width=WIDTH, height=HEIGHT)
tk.title("simulation_try1")
canvas.pack()

#TODO: Funktion, welche Richtung wechselt sobald zwei Objekte crashen
# Meine Idee (Jérôme): Array erstellen und Koordinaten eintragen, welche besetzt sind
# so muss nicht jedes Objekt mit allen anderen Objekten abgeglichen werden.

# TODO: Funktion, welche einem Objekt ein Ziel mitgibt und Objekt so steuert, dass es sich richtung Zielkoordinaten bewegt
# Problem: Wie definieren wir Koordinaten eines Objektes? (Momentan ist Objekt über 4 "Randpunkte" definiert
# Meine Idee (Jérôme): Erste Version -> anhalten sobald Zielkoordinaten erreicht
# Später: gezielt richtung Ziel bewegen

def initialize_gitter():
    #Initialisiert eine Matrix mit ran
    matrix =[[0 for x in range(HEIGHT)] for y in range(WIDTH)]
    return matrix

def print_matrix(matrix):
    #K: Funktioniert nur für Matrizen mit Höhe height
    #K: Grenze so anpassen, dass bprinteliebige Matrizen verwendet werden können?
    print("Matrixprinter")
    #print("width ", len(matrix[0]), "height ", len(matrix))
    for i in range(len(matrix)):
        print(matrix[i])

class Ball:    #print_matrix(raster
    def __init__(self, color, cord):
        #K: Initialisiert ein Objekt der Klasse
        cordx = random.randint(size, WIDTH) - size
        cordy = random.randint(size, HEIGHT) - size
        #s: create rectangle (x1, y1, x2, y2)
        self.shape = canvas.create_rectangle(cordx, cordy, (cordx + size), (cordy + size), fill=color)
        #K: Geschwindigkeiten werden zufällig verteilt
        #K: je grösser das Zufallsintervall ist, desto kleiner die Chance, dass zwei Objekte genau übereinanderliegen
        self.xspeed = random.randint(-10,10)
        self.yspeed = random.randint(-10,10)

    def move(self, matrix):
        # K: Bewegt ein Objekt, so dass er sich +/- im Fenster bewegt
        canvas.move(self.shape, self.xspeed, self.yspeed)
        pos = canvas.coords(self.shape)
        #K: Mittlere x- bzw. Y-Koordinaten
        x = int(((pos[0] + pos[2])) / 2)
        y = int(((pos[1]) + pos[3]) / 2)
        if (x >= WIDTH) or (x <= 0) or (y >= HEIGHT) or (y <= 0):
            #Ist es möglich, dass Bälle den Rahmen verlassen?
            outofrange = 1
        else:
            matrix[x][y] += 1
            return matrix

        if y >= (HEIGHT) or y <= 0:
            self.yspeed = -self.yspeed
        if x >= (WIDTH) or x <= 0:
            self.xspeed = -self.xspeed

balls = []
for i in range(100):
    #Füllt n*3 Bälle in Liste
    #K: startkoordinaten so verteilt, dass sie "zufällig" im Raum verteilt sind zu beginn
    #S: Ball(farbe, startkoordinaten)
    balls.append(Ball("yellow", 0))
    balls.append(Ball("orange", 0))
    balls.append(Ball("red", 0))
    balls.append(Ball("green", 0))
    balls.append(Ball("black", 0))

while True:
    #K: lässt Ball im Fenster herumfliegen, so dass er an den Wänden abprallt
    balls.append(Ball("magenta", 100))
    balls.append(Ball("blue", 100))
    raster = initialize_gitter()
    for ball in balls:
        ball.move(raster)
    tk.update()
    time.sleep(0.01)
    #print_matrix(raster)


tk.mainloop